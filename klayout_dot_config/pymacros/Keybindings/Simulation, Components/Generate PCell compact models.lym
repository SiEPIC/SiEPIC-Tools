<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>Generate compact models for PCells in layout</description>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>true</show-in-menu>
 <group-name>pcells</group-name>
 <menu-path>siepic_menu.simulation_components.begin</menu-path>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya

# Export an XML file containing all the PCells and their parameters
# Call the PCell simulation engine(s) to generate compact models

# Supported PCells: 
# Contra-Directional Coupler: calls Mustafaâ€™s Python simulation in the SiEPIC-EBeam-PDK / CML



import asyncio

# Export XML file containing all the PCells and their parameters
def export_PCell_parameters(filepath):

  from SiEPIC.utils import select_instances
  import os
  from xml.etree.ElementTree import ElementTree, Element, SubElement, Comment, tostring

  lv = pya.Application.instance().main_window().current_view()
  if lv == None:
    raise Exception("No view selected")
  ly = lv.active_cellview().layout()
  if ly == None:
    raise Exception("No active layout")
  cell = lv.active_cellview().cell
  if cell == None:
    raise Exception("No active cell")

  # Get the components and nets for the layout, traversing the entire hierarcy
  components = cell.find_components(verbose=False)

  for c in components:
      print (c.component)

  top = Element('PCells')
  comment = Comment('Generated by SiEPIC-Tools in KLayout')
  top.append(comment)
  count=0
  for c in components:
      print (c)
      print(c.component)
      if c.cell.is_pcell_variant():
        print(c.component)
        child = SubElement(top, 'PCell')
        child.text = c.basic_name
        child2 = SubElement(child, 'Name')
        child2.text = c.basic_name
        child2 = SubElement(child, 'Component')
        child2.text = c.component
        child2 = SubElement(child, 'ID')
        child2.text = str(count)
        params = c.cell.pcell_parameters_by_name()
        for key in params.keys():
          if type(params[key]) in [bool,int]:
            child2 = SubElement(child, key)
            child2.text = str(int(params[key]))
          elif type(params[key])==float:
            child2 = SubElement(child, key)
            child2.text = str(round(float(params[key]),14))
          elif type(params[key])==LayerInfo:
            pass
          elif type(params[key])==pya.Point:
            pass
          elif type(params[key])==pya.DPath:
            pass
          elif type(params[key])==list:
            pass
          else:
            child2 = SubElement(child, key)
            child2.text = params[key]
          print (f'{child2.text}, {type(child2.text)}')

      count+=1
  print(top)
  print (tostring(top))
  tree=ElementTree(top)

  print('Saving PCell parameters to file: %s' % filepath)

  tree.write(filepath)
  return filepath

# Import PCell parameters from XML; return an array of dict
# Bug: this function only works if there are &gt;1 components
def import_PCell_parameters(filepath):
  from SiEPIC.utils import get_technology, xml_to_dict
  print('Loading PCell parameters from file: %s' % filepath)

  with open(filepath, 'r') as file:
    d = xml_to_dict(file.read())
  print('Found %s PCells'%len(d['PCells']['PCell']))
  for PCell_params in d['PCells']['PCell']:
    print(PCell_params)
    if PCell_params['Name'] == 'Contra-Directional Coupler':
      print('CDC, gap=%s'%PCell_params['gap'])
  return d

#async def run_command_python(arguments):
def run_command_python(arguments):
    import subprocess, os

    # Load the external Python software location from the KLayout configuration
    python_path = pya.Application.instance().get_config('external_Python_executable')

    if not os.path.exists(python_path):

        python_path_options = [
            os.path.join(os.path.expanduser('~'), 'opt/anaconda3/bin/python'),
            '/usr/local/bin/python3',
            'C:\\ProgramData\\Anaconda3\\python.exe',
            os.path.join(os.path.expanduser('~'), 'Anaconda3/python.exe' )
        ]
        for p in python_path_options: 
            p = os.path.normpath(p)
            if os.path.exists(p):
                print(p)
                process = subprocess.Popen([p, '--version'], stdout=subprocess.PIPE, stderr = subprocess.PIPE, encoding='utf8')
                output1b=''; output2b=''
                while True:
                    output1 = process.stdout.readline()
                    output2 = process.stderr.readline()
                    if output1 == '' and output2 == '' and process.poll() is not None:
                        break
                    output1b+=output1; output2b+=output2
                    if output1:
                        print (output1.strip())
                    if output2:
                        print (' * ' + output2.strip())
                rc = process.poll()
                if 'Python 3' in output1b:
                    print('Found Python 3 in: %s' % p)
                    python_path = p
                    break

    # if it is still not found, ask the user
    if not os.path.exists(python_path):
        print('SiEPIC.simulation.generate PCell: External Python software not found')
        question = pya.QInputDialog()
        # (QWidget ptr parent, string title, string label)
        python_path = question.getText(pya.Application().instance().main_window(), "Python 3 path", "Please enter the path to the Python 3 executable:")

    if not os.path.exists(python_path):
        warning = pya.QMessageBox()
        warning.setStandardButtons(pya.QMessageBox.Ok)
        warning.setText("Error: SiEPIC.simulation.generate PCell: External Python software not found.")
        pya.QMessageBox_StandardButton(warning.exec_())
        return

    # Save the external Python software location to the KLayout configuration
    pya.Application.instance().set_config('external_Python_executable', python_path)
                      
    arguments.insert(0,python_path)
    process = subprocess.Popen(arguments, stdout=subprocess.PIPE, stderr = subprocess.PIPE, encoding='utf8')
#    process = await asyncio.create_subprocess_shell(arguments, stdout=subprocess.PIPE, stderr = subprocess.PIPE, encoding='utf8')
#    stdout, stderr = await process.communicate()

    stdout = ''; stderr = ''; 
    while True:
        stdout1 = process.stdout.readline()
        stderr1 = process.stderr.readline()
        if stdout1 == '' and stderr1 == '' and process.poll() is not None:
            break
        if stdout1:
            print (stdout1.strip())
            stdout += stdout1.strip()
        if stderr1:
            print (stderr1.strip())
            stderr += stderr1.strip()
    rc = process.poll()

    print(f'[{arguments!r} exited with {process.returncode}]')
    if stdout:
        print(f'[stdout]\n{stdout}')
    if stderr:
        print(f'[stderr]\n{stderr}')
        warning = pya.QMessageBox()
        warning.setStandardButtons(pya.QMessageBox.Ok)
        warning.setText("SiEPIC.simulation.generate PCell: \nPython code returned error:\n\n%s" % stderr )
        pya.QMessageBox_StandardButton(warning.exec_())
    else:
        warning = pya.QMessageBox()
        warning.setStandardButtons(pya.QMessageBox.Ok)
        warning.setText("Success: SiEPIC.simulation.generate PCell: \nCompact models generated for PCells in layout.")
        pya.QMessageBox_StandardButton(warning.exec_())
        
    

#    return rc
    return process.returncode


def python_commandline(arguments):
  print ("Running Python using the command interface.")
  import sys, os, string
  
  if sys.platform.startswith('linux'):
    import subprocess
    # Linux-specific code here...
    file_path = 'python'
    out = subprocess.check_output([file_path, arguments])
      
  
  elif sys.platform.startswith('darwin'):
    # OSX specific
    import sys
    if int(sys.version[0]) &gt; 2:
      import subprocess
      out = subprocess.check_output(['python', arguments])
    else:
      import commands
      runcmd = ('source ~/.bash_profile; python %s' % arguments)
      print("Running in shell: %s" % runcmd)
      out = commands.getstatusoutput(runcmd)

  
  elif sys.platform.startswith('win'):
    # Windows specific code here
    import subprocess
    file_path = 'python'
    out = subprocess.check_output(['python', arguments], shell=True)

  print (out)

from SiEPIC.utils import get_layout_variables

TECHNOLOGY, lv, ly, cell = get_layout_variables()
# location for the where the CMLs are installed:
filepath = os.path.normpath(os.path.join(pya.Application.instance().application_data_path(), 'Lumerical_CMLs', TECHNOLOGY['technology_name'],'source_data',
  'PCell_parameters.xml'))

export_PCell_parameters(filepath)
#import_PCell_parameters(filepath)

#arguments = filepath
#python_commandline(arguments)

#run_command(['/Users/lukasc/.klayout/Lumerical_CMLs/EBeam/source_data/CDC/main.py'])

python_main = os.path.normpath(os.path.join(os.path.dirname(filepath),'CDC/main.py'))

#await(run_command_python([python_main, filepath]))
run_command_python([python_main, filepath])
   
#run_command('/Users/lukasc/opt/anaconda3/bin/python','--version')
#run_command(['-c', '"print(100)"'])
# run_command('/Users/lukasc/opt/anaconda3/bin/python --version')

</text>
</klayout-macro>
